#install.packages("singleRcapture")
remotes::install_github("https://github.com/ncn-foreigners/singleRcapture/tree/development", force = TRUE)
library(singleRcapture)
library(doParallel)
library(foreach)
# using parallel computing
cores <- detectCores()
cl <- makeCluster(cores[1]-1) 
registerDoParallel(cl)
##### counts generated by ztoipoisson ####

# pop size
N <- 1000
sims <- 500

fn <- ztoipoisson(
  lambdaLink = "log",
  omegaLink = "cloglog"
)

# correct distribution, wrong link
fn1 <- ztoipoisson(
  omegaLink = "logit"
)

# geometric distribution
fn2 <- ztoigeom(
  omegaLink = "cloglog"
)

# Hurdle
fn3 <- ztHurdlepoisson(
  piLink = "logit"
)

fn4 <- Hurdleztpoisson(
  piLink = "logit"
)

#oizt
fn5 <- oiztpoisson(
  omegaLink = "cloglog"
)

resPoint    <- matrix(ncol = 6, nrow = sims)
resNormL    <- matrix(ncol = 6, nrow = sims)
resNormU    <- matrix(ncol = 6, nrow = sims)
resLogNormL <- matrix(ncol = 6, nrow = sims)
resLogNormU <- matrix(ncol = 6, nrow = sims)

set.seed(123)

for (k in 1L:sims) {
  cat("\nSimulation number: ", k, "\n--------", sep = "")
  # covariates
  x1 <-  runif(n = N)
  x2 <- rbinom(n = N, size = 30, prob = .4)
  x3 <-  rpois(n = N, lambda = 3)
  x4 <- rbinom(n = N, prob = .5, size = 1)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% c(-.5, -.33, .0112, 0.382, 0.915),
    cbind(1, x1, x2, x3, x4) %*% c(.33, .6, -.2, -.44, .34)
  )
  
  y <- fn$simulate(n = N, eta = eta, lower = -1)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  M4 <- NULL
  M5 <- NULL
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M4 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn4,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M5 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn5,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  
  
  resPoint[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate})
  resNormL[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]})
  resNormU[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]})
  resLogNormL[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]})
  resLogNormU[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
}

## parallel test ###

A <- foreach(k=1:sims, .combine = rbind) %dopar% {
  library(singleRcapture)
  N <- 1000
  sims <- 500
  
  fn <- ztoipoisson(
    lambdaLink = "log",
    omegaLink = "cloglog"
  )
  
  # correct distribution, wrong link
  fn1 <- ztoipoisson(
    omegaLink = "logit"
  )
  
  # geometric distribution
  fn2 <- ztoigeom(
    omegaLink = "cloglog"
  )
  
  # Hurdle
  fn3 <- ztHurdlepoisson(
    piLink = "logit"
  )
  
  fn4 <- Hurdleztpoisson(
    piLink = "logit"
  )
  
  #oizt
  fn5 <- oiztpoisson(
    omegaLink = "cloglog"
  )
  # covariates
  x1 <-  runif(n = N)
  x2 <- rbinom(n = N, size = 30, prob = .4)
  x3 <-  rpois(n = N, lambda = 3)
  x4 <- rbinom(n = N, prob = .5, size = 1)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% c(-.5, -.33, .0112, 0.382, 0.915),
    cbind(1, x1, x2, x3, x4) %*% c(.33, .6, -.2, -.44, .34)
  )
  
  y <- fn$simulate(n = N, eta = eta, lower = -1)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  M4 <- NULL
  M5 <- NULL
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M4 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn4,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M5 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn5,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  rbind(c(
    sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate}),
    sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]}),
    sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]}),
    sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]}),
    sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
  ))
}

resPoint    <- A[,1:6]
resNormL    <- A[,(1:6) + 6]
resNormU    <- A[,(1:6) + 12]
resLogNormL <- A[,(1:6) + 18]
resLogNormU <- A[,(1:6) + 24]

####

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- colnames(resLogNormL) <- colnames(resLogNormU) <- c("correct", "wrong_link", "geometric", "ztHurdle", "Hurdlezt", "oizt")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/ztoipoisson_early_results_point_est")
write.csv(resNormL, file = "results/ztoipoisson_early_results_normalL")
write.csv(resNormU, file = "results/ztoipoisson_early_results_normalU")
write.csv(resLogNormL, file = "results/ztoipoisson_early_results_log_normalL")
write.csv(resLogNormU, file = "results/ztoipoisson_early_results_log_normalU")

##### counts generated by oiztpoisson ####

# pop size
N <- 1000
sims <- 500

fn <- oiztpoisson(
  omegaLink = "cloglog"
)

# correct distribution, wrong link
fn1 <- oiztpoisson(
  omegaLink = "logit"
)

# geometric distribution
fn2 <- oiztgeom(
  omegaLink = "cloglog"
)

# Hurdle
fn3 <- ztHurdlepoisson(
  piLink = "logit"
)

fn4 <- Hurdleztpoisson(
  piLink = "logit"
)

fn5 <- ztoipoisson(
  omegaLink = "cloglog"
)

resPoint    <- matrix(ncol = 6, nrow = sims)
resNormL    <- matrix(ncol = 6, nrow = sims)
resNormU    <- matrix(ncol = 6, nrow = sims)
resLogNormL <- matrix(ncol = 6, nrow = sims)
resLogNormU <- matrix(ncol = 6, nrow = sims)

set.seed(123)

for (k in 1L:sims) {
  cat("\nSimulation number: ", k, "\n--------", sep = "")
  # covariates
  x1 <-  runif(n = N)
  x2 <- rbinom(n = N, size = 30, prob = .4)
  x3 <-  rpois(n = N, lambda = 3)
  x4 <- rbinom(n = N, prob = .5, size = 1)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% c(-.5, -.33, .0112, 0.382, 0.915),
    cbind(1, x1, x2, x3, x4) %*% c(.33, .6, -.2, -.44, .34)
  )
  
  y <- fn$simulate(n = N, eta = eta, lower = -1)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  M4 <- NULL
  M5 <- NULL
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M4 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn4,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M5 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn5,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  
  
  resPoint[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate})
  resNormL[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]})
  resNormU[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]})
  resLogNormL[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]})
  resLogNormU[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
}

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- colnames(resLogNormL) <- colnames(resLogNormU) <- c("correct", "wrong_link", "geometric", "ztHurdle", "Hurdlezt", "ztoi")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/oiztpoisson_early_results_point_est")
write.csv(resNormL, file = "results/oiztpoisson_early_results_normalL")
write.csv(resNormU, file = "results/oiztpoisson_early_results_normalU")
write.csv(resLogNormL, file = "results/oiztpoisson_early_results_log_normalL")
write.csv(resLogNormU, file = "results/oiztpoisson_early_results_log_normalU")

##### counts generated by ztHurdlepoisson ####

# pop size
N <- 1000
sims <- 500

fn <- ztHurdlepoisson(
  piLink = "logit"
)

# correct distribution, wrong link
fn1 <- ztHurdlepoisson(
  piLink = "cloglog"
)

# geometric distribution
fn2 <- ztHurdlegeom(
  piLink = "logit"
)

fn3 <- oiztpoisson(
  omegaLink = "logit"
)

fn4 <- Hurdleztpoisson(
  piLink = "logit"
)

fn5 <- ztoipoisson(
  omegaLink = "logit"
)

resPoint    <- matrix(ncol = 6, nrow = sims)
resNormL    <- matrix(ncol = 6, nrow = sims)
resNormU    <- matrix(ncol = 6, nrow = sims)
resLogNormL <- matrix(ncol = 6, nrow = sims)
resLogNormU <- matrix(ncol = 6, nrow = sims)

set.seed(123)

for (k in 1L:sims) {
  cat("\nSimulation number: ", k, "\n--------", sep = "")
  # covariates
  x1 <-  runif(n = N)
  x2 <- rbinom(n = N, size = 30, prob = .4)
  x3 <-  rpois(n = N, lambda = 3)
  x4 <- rbinom(n = N, prob = .5, size = 1)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% c(-.5, -.33, .0112, 0.382, 0.915),
    cbind(1, x1, x2, x3, x4) %*% c(.33, .6, -.2, -.44, .34)
  )
  
  y <- fn$simulate(n = N, eta = eta, lower = -1)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  M4 <- NULL
  M5 <- NULL
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M4 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn4,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M5 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn5,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  
  
  resPoint[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate})
  resNormL[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]})
  resNormU[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]})
  resLogNormL[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]})
  resLogNormU[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
}

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- colnames(resLogNormL) <- colnames(resLogNormU) <- c("correct", "wrong_link", "geometric", "oizt", "Hurdlezt", "ztoi")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/ztHurdlepoisson_early_results_point_est")
write.csv(resNormL, file = "results/ztHurdlepoisson_early_results_normalL")
write.csv(resNormU, file = "results/ztHurdlepoisson_early_results_normalU")
write.csv(resLogNormL, file = "results/ztHurdlepoisson_early_results_log_normalL")
write.csv(resLogNormU, file = "results/ztHurdlepoisson_early_results_log_normalU")

##### counts generated by Hurdleztpoisson ####

# pop size
N <- 1000
sims <- 500

fn <- Hurdleztpoisson(
  piLink = "logit"
)

# correct distribution, wrong link
fn1 <- Hurdleztpoisson(
  piLink = "probit"
)

# geometric distribution
fn2 <- Hurdleztgeom(
  piLink = "logit"
)

fn3 <- oiztpoisson(
  omegaLink = "logit"
)

fn4 <- ztHurdlepoisson(
  piLink = "logit"
)

fn5 <- ztoipoisson(
  omegaLink = "logit"
)

resPoint    <- matrix(ncol = 6, nrow = sims)
resNormL    <- matrix(ncol = 6, nrow = sims)
resNormU    <- matrix(ncol = 6, nrow = sims)
resLogNormL <- matrix(ncol = 6, nrow = sims)
resLogNormU <- matrix(ncol = 6, nrow = sims)

set.seed(123)

for (k in 1L:sims) {
  cat("\nSimulation number: ", k, "\n--------", sep = "")
  # covariates
  x1 <-  runif(n = N)
  x2 <- rbinom(n = N, size = 30, prob = .4)
  x3 <-  rpois(n = N, lambda = 3)
  x4 <- rbinom(n = N, prob = .5, size = 1)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% c(-.5, -.33, .0112, 0.382, 0.915),
    cbind(1, x1, x2, x3, x4) %*% c(.33, .6, -.2, -.44, .34)
  )
  
  y <- fn$simulate(n = N, eta = eta, lower = -1)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  M4 <- NULL
  M5 <- NULL
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M4 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn4,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M5 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn5,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  
  
  resPoint[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate})
  resNormL[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]})
  resNormU[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]})
  resLogNormL[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]})
  resLogNormU[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
}

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- colnames(resLogNormL) <- colnames(resLogNormU) <- c("correct", "wrong_link", "geometric", "oizt", "ztHurdle", "ztoi")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/Hurdleztpoisson_early_results_point_est")
write.csv(resNormL, file = "results/Hurdleztpoisson_early_results_normalL")
write.csv(resNormU, file = "results/Hurdleztpoisson_early_results_normalU")
write.csv(resLogNormL, file = "results/Hurdleztpoisson_early_results_log_normalL")
write.csv(resLogNormU, file = "results/Hurdleztpoisson_early_results_log_normalU")

##### counts generated by ztoigeom ####

# pop size
N <- 1000
sims <- 500

fn <- ztoigeom(
  lambdaLink = "log",
  omegaLink = "cloglog"
)

# correct distribution, wrong link
fn1 <- ztoigeom(
  omegaLink = "logit"
)

# poisson distribution
fn2 <- ztoipoisson(
  omegaLink = "cloglog"
)

# negative binomial distribution
fn3 <- ztoinegbin(
  omegaLink = "cloglog"
)

# Hurdle
fn4 <- ztHurdlegeom(
  piLink = "cloglog"
)

fn5 <- Hurdleztgeom(
  piLink = "cloglog"
)

#oizt
fn6 <- oiztgeom(
  omegaLink = "cloglog"
)

resPoint    <- matrix(ncol = 7, nrow = sims)
resNormL    <- matrix(ncol = 7, nrow = sims)
resNormU    <- matrix(ncol = 7, nrow = sims)
resLogNormL <- matrix(ncol = 7, nrow = sims)
resLogNormU <- matrix(ncol = 7, nrow = sims)

set.seed(123)

for (k in 1L:sims) {
  cat("\nSimulation number: ", k, "\n--------", sep = "")
  # covariates
  x1 <-  runif(n = N)
  x2 <- rbinom(n = N, size = 30, prob = .4)
  x3 <-  rpois(n = N, lambda = 3)
  x4 <- rbinom(n = N, prob = .5, size = 1)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% c(-.5, -.33, .0112, 0.382, 0.915),
    cbind(1, x1, x2, x3, x4) %*% c(.33, .6, -.2, -.44, .34)
  )
  
  y <- fn$simulate(n = N, eta = eta, lower = -1)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  M4 <- NULL
  M5 <- NULL
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M4 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn4,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M5 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn5,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M6 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn6,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  
  
  resPoint[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate})
  resNormL[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]})
  resNormU[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]})
  resLogNormL[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]})
  resLogNormU[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
}

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- colnames(resLogNormL) <- colnames(resLogNormU) <- c("correct", "wrong_link", "poisson", "negbin", "ztHurdle", "Hurdlezt", "oizt")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/ztoigeom_early_results_point_est")
write.csv(resNormL, file = "results/ztoigeom_early_results_normalL")
write.csv(resNormU, file = "results/ztoigeom_early_results_normalU")
write.csv(resLogNormL, file = "results/ztoigeom_early_results_log_normalL")
write.csv(resLogNormU, file = "results/ztoigeom_early_results_log_normalU")

##### counts generated by oiztgeom ####

# pop size
N <- 1000
sims <- 500

fn <- oiztgeom(
  lambdaLink = "log",
  omegaLink = "cloglog"
)

# correct distribution, wrong link
fn1 <- oiztgeom(
  omegaLink = "logit"
)

# poisson distribution
fn2 <- oiztpoisson(
  omegaLink = "cloglog"
)

# negative binomial distribution
fn3 <- oiztnegbin(
  omegaLink = "cloglog"
)

# Hurdle
fn4 <- ztHurdlegeom(
  piLink = "cloglog"
)

fn5 <- Hurdleztgeom(
  piLink = "cloglog"
)

#oizt
fn6 <- ztoigeom(
  omegaLink = "cloglog"
)

resPoint    <- matrix(ncol = 7, nrow = sims)
resNormL    <- matrix(ncol = 7, nrow = sims)
resNormU    <- matrix(ncol = 7, nrow = sims)
resLogNormL <- matrix(ncol = 7, nrow = sims)
resLogNormU <- matrix(ncol = 7, nrow = sims)

set.seed(123)

for (k in 1L:sims) {
  cat("\nSimulation number: ", k, "\n--------", sep = "")
  # covariates
  x1 <-  runif(n = N)
  x2 <- rbinom(n = N, size = 30, prob = .4)
  x3 <-  rpois(n = N, lambda = 3)
  x4 <- rbinom(n = N, prob = .5, size = 1)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% c(-.5, -.33, .0112, 0.382, 0.915),
    cbind(1, x1, x2, x3, x4) %*% c(.33, .6, -.2, -.44, .34)
  )
  
  y <- fn$simulate(n = N, eta = eta, lower = -1)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  M4 <- NULL
  M5 <- NULL
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M4 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn4,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M5 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn5,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M6 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn6,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  
  
  resPoint[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate})
  resNormL[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]})
  resNormU[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]})
  resLogNormL[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]})
  resLogNormU[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
}

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- colnames(resLogNormL) <- colnames(resLogNormU) <- c("correct", "wrong_link", "poisson", "negbin", "ztHurdle", "Hurdlezt", "ztoi")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/oiztgeom_early_results_point_est")
write.csv(resNormL, file = "results/oiztgeom_early_results_normalL")
write.csv(resNormU, file = "results/oiztgeom_early_results_normalU")
write.csv(resLogNormL, file = "results/oiztgeom_early_results_log_normalL")
write.csv(resLogNormU, file = "results/oiztgeom_early_results_log_normalU")

##### counts generated by ztHurdlegeom ####

# pop size
N <- 1000
sims <- 500

fn <- ztHurdlegeom(
  piLink = "logit"
)

# correct distribution, wrong link
fn1 <- ztHurdlegeom(
  piLink = "cloglog"
)

# poisson distribution
fn2 <- ztHurdlepoisson(
  piLink = "logit"
)

# negative binomial distribution
fn3 <- ztHurdlenegbin(
  piLink = "logit"
)

fn4 <- oiztgeom(
  omegaLink = "logit"
)

fn5 <- Hurdleztgeom(
  piLink = "logit"
)

#oizt
fn6 <- ztoigeom(
  omegaLink = "logit"
)

resPoint    <- matrix(ncol = 7, nrow = sims)
resNormL    <- matrix(ncol = 7, nrow = sims)
resNormU    <- matrix(ncol = 7, nrow = sims)
resLogNormL <- matrix(ncol = 7, nrow = sims)
resLogNormU <- matrix(ncol = 7, nrow = sims)

set.seed(123)

for (k in 1L:sims) {
  cat("\nSimulation number: ", k, "\n--------", sep = "")
  # covariates
  x1 <-  runif(n = N)
  x2 <- rbinom(n = N, size = 30, prob = .4)
  x3 <-  rpois(n = N, lambda = 3)
  x4 <- rbinom(n = N, prob = .5, size = 1)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% c(-.5, -.33, .0112, 0.382, 0.915),
    cbind(1, x1, x2, x3, x4) %*% c(.33, .6, -.2, -.44, .34)
  )
  
  y <- fn$simulate(n = N, eta = eta, lower = -1)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  M4 <- NULL
  M5 <- NULL
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M4 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn4,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M5 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn5,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M6 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn6,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  
  
  resPoint[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate})
  resNormL[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]})
  resNormU[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]})
  resLogNormL[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]})
  resLogNormU[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
}

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- colnames(resLogNormL) <- colnames(resLogNormU) <- c("correct", "wrong_link", "poisson", "negbin", "oizt", "Hurdlezt", "ztoi")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/ztHurdlegeom_early_results_point_est")
write.csv(resNormL, file = "results/ztHurdlegeom_early_results_normalL")
write.csv(resNormU, file = "results/ztHurdlegeom_early_results_normalU")
write.csv(resLogNormL, file = "results/ztHurdlegeom_early_results_log_normalL")
write.csv(resLogNormU, file = "results/ztHurdlegeom_early_results_log_normalU")

##### counts generated by Hurdleztgeom ####

# pop size
N <- 1000
sims <- 500

fn <- Hurdleztgeom(
  piLink = "logit"
)

# correct distribution, wrong link
fn1 <- Hurdleztgeom(
  piLink = "cloglog"
)

# poisson distribution
fn2 <- Hurdleztpoisson(
  piLink = "logit"
)

# negative binomial distribution
fn3 <- Hurdleztnegbin(
  piLink = "logit"
)

fn4 <- oiztgeom(
  omegaLink = "logit"
)

fn5 <- ztHurdlegeom(
  piLink = "logit"
)

#oizt
fn6 <- ztoigeom(
  omegaLink = "logit"
)

resPoint    <- matrix(ncol = 7, nrow = sims)
resNormL    <- matrix(ncol = 7, nrow = sims)
resNormU    <- matrix(ncol = 7, nrow = sims)
resLogNormL <- matrix(ncol = 7, nrow = sims)
resLogNormU <- matrix(ncol = 7, nrow = sims)

set.seed(123)

for (k in 1L:sims) {
  cat("\nSimulation number: ", k, "\n--------", sep = "")
  # covariates
  x1 <-  runif(n = N)
  x2 <- rbinom(n = N, size = 30, prob = .4)
  x3 <-  rpois(n = N, lambda = 3)
  x4 <- rbinom(n = N, prob = .5, size = 1)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% c(-.5, -.33, .0112, 0.382, 0.915),
    cbind(1, x1, x2, x3, x4) %*% c(.33, .6, -.2, -.44, .34)
  )
  
  y <- fn$simulate(n = N, eta = eta, lower = -1)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  M4 <- NULL
  M5 <- NULL
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M4 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn4,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M5 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn5,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M6 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn6,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  
  
  resPoint[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate})
  resNormL[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]})
  resNormU[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]})
  resLogNormL[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]})
  resLogNormU[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
}

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- colnames(resLogNormL) <- colnames(resLogNormU) <- c("correct", "wrong_link", "poisson", "negbin", "oizt", "ztHurdle", "ztoi")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/Hurdleztgeom_early_results_point_est")
write.csv(resNormL, file = "results/Hurdleztgeom_early_results_normalL")
write.csv(resNormU, file = "results/Hurdleztgeom_early_results_normalU")
write.csv(resLogNormL, file = "results/Hurdleztgeom_early_results_log_normalL")
write.csv(resLogNormU, file = "results/Hurdleztgeom_early_results_log_normalU")


##### counts generated by ztoinegbin ####

# pop size
N <- 1000
sims <- 500

fn <- ztoinegbin(
  lambdaLink = "log",
  omegaLink = "cloglog"
)

# correct distribution, wrong link
fn1 <- ztoinegbin(
  omegaLink = "logit"
)

# poisson distribution
fn2 <- ztoipoisson(
  omegaLink = "cloglog"
)

# negative binomial distribution
fn3 <- ztoigeom(
  omegaLink = "cloglog"
)

# Hurdle
fn4 <- ztHurdlenegbin(
  piLink = "cloglog"
)

fn5 <- Hurdleztnegbin(
  piLink = "cloglog"
)

#oizt
fn6 <- oiztnegbin(
  omegaLink = "cloglog"
)

resPoint    <- matrix(ncol = 7, nrow = sims)
resNormL    <- matrix(ncol = 7, nrow = sims)
resNormU    <- matrix(ncol = 7, nrow = sims)
resLogNormL <- matrix(ncol = 7, nrow = sims)
resLogNormU <- matrix(ncol = 7, nrow = sims)

set.seed(123)

for (k in 1L:sims) {
  cat("\nSimulation number: ", k, "\n--------", sep = "")
  # covariates
  x1 <-  runif(n = N)
  x2 <- rbinom(n = N, size = 30, prob = .4)
  x3 <-  rpois(n = N, lambda = 3)
  x4 <- rbinom(n = N, prob = .5, size = 1)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% c(-.5, -.33, .0112, 0.382, 0.915),
    log(pi),
    cbind(1, x1, x2, x3, x4) %*% c(.33, .6, -.2, -.44, .34)
  )
  
  y <- fn$simulate(n = N, eta = eta, lower = -1)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  M4 <- NULL
  M5 <- NULL
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M4 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn4,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M5 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn5,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M6 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn6,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  
  
  resPoint[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate})
  resNormL[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]})
  resNormU[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]})
  resLogNormL[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]})
  resLogNormU[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
}

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- colnames(resLogNormL) <- colnames(resLogNormU) <- c("correct", "wrong_link", "poisson", "geom", "ztHurdle", "Hurdlezt", "oizt")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/ztoinegbin_early_results_point_est")
write.csv(resNormL, file = "results/ztoinegbin_early_results_normalL")
write.csv(resNormU, file = "results/ztoinegbin_early_results_normalU")
write.csv(resLogNormL, file = "results/ztoinegbin_early_results_log_normalL")
write.csv(resLogNormU, file = "results/ztoinegbin_early_results_log_normalU")

##### counts generated by oiztnegbin ####

# pop size
N <- 1000
sims <- 500

fn <- oiztnegbin(
  lambdaLink = "log",
  omegaLink = "cloglog"
)

# correct distribution, wrong link
fn1 <- oiztnegbin(
  omegaLink = "logit"
)

# poisson distribution
fn2 <- oiztpoisson(
  omegaLink = "cloglog"
)

# negative binomial distribution
fn3 <- oiztgeom(
  omegaLink = "cloglog"
)

# Hurdle
fn4 <- ztHurdlenegbin(
  piLink = "cloglog"
)

fn5 <- Hurdleztnegbin(
  piLink = "cloglog"
)

#oizt
fn6 <- ztoinegbin(
  omegaLink = "cloglog"
)

resPoint    <- matrix(ncol = 7, nrow = sims)
resNormL    <- matrix(ncol = 7, nrow = sims)
resNormU    <- matrix(ncol = 7, nrow = sims)
resLogNormL <- matrix(ncol = 7, nrow = sims)
resLogNormU <- matrix(ncol = 7, nrow = sims)

set.seed(123)

for (k in 1L:sims) {
  cat("\nSimulation number: ", k, "\n--------", sep = "")
  # covariates
  x1 <-  runif(n = N)
  x2 <- rbinom(n = N, size = 30, prob = .4)
  x3 <-  rpois(n = N, lambda = 3)
  x4 <- rbinom(n = N, prob = .5, size = 1)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% c(-.5, -.33, .0112, 0.382, 0.915),
    log(pi),
    cbind(1, x1, x2, x3, x4) %*% c(.33, .6, -.2, -.44, .34)
  )
  
  y <- fn$simulate(n = N, eta = eta, lower = -1)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  M4 <- NULL
  M5 <- NULL
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M4 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn4,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M5 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn5,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M6 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn6,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  
  
  resPoint[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate})
  resNormL[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]})
  resNormU[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]})
  resLogNormL[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]})
  resLogNormU[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
}

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- colnames(resLogNormL) <- colnames(resLogNormU) <- c("correct", "wrong_link", "poisson", "geom", "ztHurdle", "Hurdlezt", "ztoi")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/oiztnegbin_early_results_point_est")
write.csv(resNormL, file = "results/oiztnegbin_early_results_normalL")
write.csv(resNormU, file = "results/oiztnegbin_early_results_normalU")
write.csv(resLogNormL, file = "results/oiztnegbin_early_results_log_normalL")
write.csv(resLogNormU, file = "results/oiztnegbin_early_results_log_normalU")

##### counts generated by ztHurdlenegbin ####

# pop size
N <- 1000
sims <- 500

fn <- ztHurdlenegbin(
  piLink = "logit"
)

# correct distribution, wrong link
fn1 <- ztHurdlenegbin(
  piLink = "cloglog"
)

# poisson distribution
fn2 <- ztHurdlepoisson(
  piLink = "logit"
)

# negative binomial distribution
fn3 <- ztHurdlegeom(
  piLink = "logit"
)

fn4 <- oiztnegbin(
  omegaLink = "logit"
)

fn5 <- Hurdleztnegbin(
  piLink = "logit"
)

#oizt
fn6 <- ztoinegbin(
  omegaLink = "logit"
)

resPoint    <- matrix(ncol = 7, nrow = sims)
resNormL    <- matrix(ncol = 7, nrow = sims)
resNormU    <- matrix(ncol = 7, nrow = sims)
resLogNormL <- matrix(ncol = 7, nrow = sims)
resLogNormU <- matrix(ncol = 7, nrow = sims)

set.seed(123)

for (k in 1L:sims) {
  cat("\nSimulation number: ", k, "\n--------", sep = "")
  # covariates
  x1 <-  runif(n = N)
  x2 <- rbinom(n = N, size = 30, prob = .4)
  x3 <-  rpois(n = N, lambda = 3)
  x4 <- rbinom(n = N, prob = .5, size = 1)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% c(-.5, -.33, .0112, 0.382, 0.915),
    log(pi),
    cbind(1, x1, x2, x3, x4) %*% c(.33, .6, -.2, -.44, .34)
  )
  
  y <- fn$simulate(n = N, eta = eta, lower = -1)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  M4 <- NULL
  M5 <- NULL
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M4 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn4,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M5 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn5,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M6 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn6,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  
  
  resPoint[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate})
  resNormL[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]})
  resNormU[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]})
  resLogNormL[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]})
  resLogNormU[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
}

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- colnames(resLogNormL) <- colnames(resLogNormU) <- c("correct", "wrong_link", "poisson", "geom", "oizt", "Hurdlezt", "ztoi")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/ztHurdlenegbin_early_results_point_est")
write.csv(resNormL, file = "results/ztHurdlenegbin_early_results_normalL")
write.csv(resNormU, file = "results/ztHurdlenegbin_early_results_normalU")
write.csv(resLogNormL, file = "results/ztHurdlenegbin_early_results_log_normalL")
write.csv(resLogNormU, file = "results/ztHurdlenegbin_early_results_log_normalU")

##### counts generated by Hurdleztnegbin ####

# pop size
N <- 1000
sims <- 500

fn <- Hurdleztnegbin(
  piLink = "logit"
)

# correct distribution, wrong link
fn1 <- Hurdleztnegbin(
  piLink = "cloglog"
)

# poisson distribution
fn2 <- Hurdleztpoisson(
  piLink = "logit"
)

# negative binomial distribution
fn3 <- Hurdleztgeom(
  piLink = "logit"
)

fn4 <- oiztnegbin(
  omegaLink = "logit"
)

fn5 <- ztHurdlenegbin(
  piLink = "logit"
)

#oizt
fn6 <- ztoinegbin(
  omegaLink = "logit"
)

resPoint    <- matrix(ncol = 7, nrow = sims)
resNormL    <- matrix(ncol = 7, nrow = sims)
resNormU    <- matrix(ncol = 7, nrow = sims)
resLogNormL <- matrix(ncol = 7, nrow = sims)
resLogNormU <- matrix(ncol = 7, nrow = sims)

set.seed(123)

for (k in 1L:sims) {
  cat("\nSimulation number: ", k, "\n--------", sep = "")
  # covariates
  x1 <-  runif(n = N)
  x2 <- rbinom(n = N, size = 30, prob = .4)
  x3 <-  rpois(n = N, lambda = 3)
  x4 <- rbinom(n = N, prob = .5, size = 1)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% c(-.5, -.33, .0112, 0.382, 0.915),
    log(pi),
    cbind(1, x1, x2, x3, x4) %*% c(.33, .6, -.2, -.44, .34)
  )
  
  y <- fn$simulate(n = N, eta = eta, lower = -1)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  M4 <- NULL
  M5 <- NULL
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M4 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn4,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M5 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn5,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  try(
    M6 <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn6,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE
      )
    ),
    silent = TRUE
  )
  
  
  
  resPoint[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate})
  resNormL[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]})
  resNormU[k, ]     <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]})
  resLogNormL[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]})
  resLogNormU[k, ]  <- sapply(list(M, M1, M2, M3, M4, M5, M6), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
}

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- colnames(resLogNormL) <- colnames(resLogNormU) <- c("correct", "wrong_link", "poisson", "geom", "oizt", "ztHurdle", "ztoi")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/Hurdleztnegbin_early_results_point_est")
write.csv(resNormL, file = "results/Hurdleztnegbin_early_results_normalL")
write.csv(resNormU, file = "results/Hurdleztnegbin_early_results_normalU")
write.csv(resLogNormL, file = "results/Hurdleztnegbin_early_results_log_normalL")
write.csv(resLogNormU, file = "results/Hurdleztnegbin_early_results_log_normalU")

