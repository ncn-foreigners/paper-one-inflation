#install.packages("singleRcapture")
remotes::install_github("https://github.com/ncn-foreigners/singleRcapture/tree/development", force = TRUE)
library(singleRcapture)
library(doParallel)
library(foreach)
library(igraph)
# using parallel computing
cores <- detectCores()[1] - 1

##### counts generated by ztoipoisson ####
# send model info to each core
# pop size
N <- 5000
sims <- 500

fn <- ztoipoisson()
fn1 <- Hurdleztpoisson()
fn2 <- oiztpoisson()
fn3 <- ztHurdlepoisson()

x1 <-  runif(n = N)
x2 <- rbinom(n = N, size = 30, prob = .4)
x3 <-  rpois(n = N, lambda = 3)
x4 <- rbinom(n = N, prob = .5, size = 1)
eta <- cbind(
  cbind(1, x1, x2, x3, x4) %*% c(-.5, -.33, .0112, 0.382, 0.915),
  cbind(1, x1, x2, x3, x4) %*% c(.33, .6, -.2, -.44, .34)
)

y <- simulate(fn, eta = eta)

df <- data.frame(
  y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
)

df <- df[df$y>0, ]

# Contaminate 1 ####

iddx <- sample(which(df$y > 2), size = .025*NROW(df))

dddd <- df
for (k in iddx) {
  M <- dddd[k, ]
  dddd <- dddd[-k, ]
  
  dddd[NROW(dddd)+1:M[,"y"][[1]], ] <- cbind(1, t(sapply(1:M[,"y"][[1]], FUN = function(x) M[,-1]))) |> as.data.frame()
}

dddd <- sapply(dddd, FUN = unlist) |> as.data.frame()

M_true <- estimatePopsize(
  formula = y ~ .,
  data = df,
  model = fn,
  controlModel = controlModel(
    piFormula    = ~ .,
    omegaFormula = ~ .
  ),
  controlMethod = controlMethod(
    verbose = 5
  )
)

M <- estimatePopsize(
  formula = y ~ .,
  data = dddd,
  model = fn,
  controlModel = controlModel(
    piFormula    = ~ .,
    omegaFormula = ~ .
  ),
  popVar = "bootstrap",
  controlPopVar = controlPopVar(
    cores = 7
  ),
  controlMethod = controlMethod(
    verbose = 5
  )
)

M1 <- estimatePopsize(
  formula = y ~ .,
  data = dddd,
  model = fn1,
  controlModel = controlModel(
    piFormula    = ~ .,
    omegaFormula = ~ .
  ),
  popVar = "bootstrap",
  controlPopVar = controlPopVar(
    cores = 7
  ),
  controlMethod = controlMethod(
    verbose = 5
  )
)

M2 <- estimatePopsize(
  formula = y ~ .,
  data = dddd,
  model = fn2,
  controlModel = controlModel(
    piFormula    = ~ .,
    omegaFormula = ~ .
  ),
  popVar = "bootstrap",
  controlPopVar = controlPopVar(
    cores = 7
  ),
  controlMethod = controlMethod(
    verbose = 5
  )
)

M3 <- estimatePopsize(
  formula = y ~ .,
  data = dddd,
  model = fn3,
  controlModel = controlModel(
    piFormula    = ~ .,
    omegaFormula = ~ .
  ),
  popVar = "bootstrap",
  controlPopVar = controlPopVar(
    cores = 7
  ),
  controlMethod = controlMethod(
    verbose = 5
  )
)

lapply(list(M_true, M, M1, M2, M3), popSizeEst)


# Contaminate 2 ####
iddx <- sample(which(df$y > 2), size = .025*NROW(df))

dddd <- df
for (k in iddx) {
  M <- dddd[k, ]
  dddd <- dddd[-k, ]
  
  yy <- vector(mode = "numeric")
  while (sum(yy) < M[,"y"][[1]]) {
    yy[length(yy) + 1] <- sample(size = 1, x = 1:(M[,"y"][[1]]-sum(yy)))
  }
  
  dddd[NROW(dddd)+1:length(yy), ] <- cbind(yy, t(sapply(1:length(yy), FUN = function(x) M[,-1]))) |> as.data.frame()
}

dddd <- sapply(dddd, FUN = unlist) |> as.data.frame()

M_true <- estimatePopsize(
  formula = y ~ .,
  data = df,
  model = fn,
  controlModel = controlModel(
    piFormula    = ~ .,
    omegaFormula = ~ .
  ),
  controlMethod = controlMethod(
    verbose = 5
  )
)

M <- estimatePopsize(
  formula = y ~ .,
  data = dddd,
  model = fn,
  controlModel = controlModel(
    piFormula    = ~ .,
    omegaFormula = ~ .
  ),
  popVar = "bootstrap",
  controlPopVar = controlPopVar(
    cores = 7
  ),
  controlMethod = controlMethod(
    verbose = 5
  )
)

M1 <- estimatePopsize(
  formula = y ~ .,
  data = dddd,
  model = fn1,
  controlModel = controlModel(
    piFormula    = ~ .,
    omegaFormula = ~ .
  ),
  popVar = "bootstrap",
  controlPopVar = controlPopVar(
    cores = 7
  ),
  controlMethod = controlMethod(
    verbose = 5
  )
)

M2 <- estimatePopsize(
  formula = y ~ .,
  data = dddd,
  model = fn2,
  controlModel = controlModel(
    piFormula    = ~ .,
    omegaFormula = ~ .
  ),
  popVar = "bootstrap",
  controlPopVar = controlPopVar(
    cores = 7
  ),
  controlMethod = controlMethod(
    verbose = 5
  )
)

M3 <- estimatePopsize(
  formula = y ~ .,
  data = dddd,
  model = fn3,
  controlModel = controlModel(
    piFormula    = ~ .,
    omegaFormula = ~ .
  ),
  popVar = "bootstrap",
  controlPopVar = controlPopVar(
    cores = 7
  ),
  controlMethod = controlMethod(
    verbose = 5
  )
)

lapply(list(M_true, M, M1, M2, M3), popSizeEst)

# combining different units ####
rownames(df) <- 1:NROW(df)
iddx1 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
iddx2 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)

graph_matrix <- matrix(
  FALSE,
  nrow = length(unique(iddx1)),
  ncol = length(unique(iddx2)),
  dimnames = list(unique(iddx1), unique(iddx2))
)

graph <- graph_from_data_frame(d = data.frame(iddx1, iddx2), directed=FALSE)
cmp <- components(graph)
cliques <- cmp$membership |> unique()
cliques <- lapply(cliques, function (x) names(which(cmp$membership == x)))

dddd <- df
for (k in cliques) {
  M <- dddd[k, ]
  dddd <- dddd[!(rownames(dddd) %in% k), ]
  
  dddd[NROW(dddd)+1, ] <- colSums(M) / c(1, rep(NROW(M), NCOL(M) - 1))
}

dddd <- sapply(dddd, FUN = unlist) |> as.data.frame()

M_true <- estimatePopsize(
  formula = y ~ .,
  data = df,
  model = fn,
  controlModel = controlModel(
    piFormula    = ~ .,
    omegaFormula = ~ .
  ),
  controlMethod = controlMethod(
    verbose = 5
  )
)

M <- estimatePopsize(
  formula = y ~ .,
  data = dddd,
  model = fn,
  controlModel = controlModel(
    piFormula    = ~ .,
    omegaFormula = ~ .
  ),
  popVar = "bootstrap",
  controlPopVar = controlPopVar(
    cores = 7
  ),
  controlMethod = controlMethod(
    verbose = 5
  )
)

M1 <- estimatePopsize(
  formula = y ~ .,
  data = dddd,
  model = fn1,
  controlModel = controlModel(
    piFormula    = ~ .,
    omegaFormula = ~ .
  ),
  popVar = "bootstrap",
  controlPopVar = controlPopVar(
    cores = 7
  ),
  controlMethod = controlMethod(
    verbose = 5
  )
)

M2 <- estimatePopsize(
  formula = y ~ .,
  data = dddd,
  model = fn2,
  controlModel = controlModel(
    piFormula    = ~ .,
    omegaFormula = ~ .
  ),
  popVar = "bootstrap",
  controlPopVar = controlPopVar(
    cores = 7
  ),
  controlMethod = controlMethod(
    verbose = 5, stepsize = .8
  )
)

M3 <- estimatePopsize(
  formula = y ~ .,
  data = dddd,
  model = fn3,
  controlModel = controlModel(
    piFormula    = ~ .,
    omegaFormula = ~ .
  ),
  popVar = "bootstrap",
  controlPopVar = controlPopVar(
    cores = 7
  ),
  controlMethod = controlMethod(
    verbose = 5
  )
)

lapply(list(M_true, M, M1, M2, M3), popSizeEst)
