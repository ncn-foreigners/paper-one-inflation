#install.packages("singleRcapture")
remotes::install_github("https://github.com/ncn-foreigners/singleRcapture/tree/development", force = TRUE)
library(singleRcapture)
library(doParallel)
library(foreach)
library(igraph)
# using parallel computing
cores <- detectCores()[1] - 1

##### counts generated by ztoipoisson ####
# send model info to each core
# pop size
N <- 2500
sims <- 500

fn <- ztoipoisson()
fn1 <- Hurdleztpoisson()
fn2 <- oiztpoisson()
fn3 <- ztHurdlepoisson()

cl <- makeCluster(cores)
clusterExport(cl, c("N", "sims", "fn", "fn1", "fn2", "fn3"))
registerDoParallel(cl)

A <- foreach(k=1:sims, .combine = rbind, .packages = c("singleRcapture", "igraph")) %dopar% {
  x1 <- rnorm(n = N)
  x2 <- rnorm(n = N)
  x3 <- rnorm(n = N)
  x4 <- rnorm(n = N)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8),
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8)
  )
  
  y <- simulate(fn, eta = eta)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  # spliting
  iddx <- sample(which(df$y > 1), size = .03*NROW(df))
  dddd <- df
  for (k in iddx) {
    M <- dddd[k, ]
    dddd <- dddd[-k, ]
    
    yy <- vector(mode = "numeric")
    while (sum(yy) < M[,"y"][[1]]) {
      yy[length(yy) + 1] <- sample(size = 1, x = 1:(M[,"y"][[1]]-sum(yy)))
    }
    
    dddd[NROW(dddd)+1:length(yy), ] <- cbind(yy, t(sapply(1:length(yy), FUN = function(x) M[,-1]))) |> as.data.frame()
  }
  
  dddd <- sapply(dddd, FUN = unlist) |> as.data.frame()
  
  # combining
  rownames(df) <- 1:NROW(df)
  iddx1 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  iddx2 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  
  graph <- graph_from_data_frame(d = data.frame(iddx1, iddx2), directed=FALSE)
  cmp <- components(graph)
  cliques <- cmp$membership |> unique()
  cliques <- lapply(cliques, function (x) names(which(cmp$membership == x)))
  
  dddd1 <- df
  for (k in cliques) {
    M <- dddd1[k, ]
    dddd1 <- dddd1[!(rownames(dddd1) %in% k), ]
    
    dddd[NROW(dddd1)+1, ] <- colSums(M) / c(1, rep(NROW(M), NCOL(M) - 1))
  }
  
  dddd1 <- sapply(dddd1, FUN = unlist) |> as.data.frame()
  
  M_true <- NULL
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  
  R  <- NULL
  R1 <- NULL
  R2 <- NULL
  R3 <- NULL
  
  try(
    M_true <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    )
  )
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  rbind(c(
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
  ))
}

stopCluster(cl)

resPoint    <- A[,1:9]
resNormL    <- A[,(1:9) + 9]
resNormU    <- A[,(1:9) + 18]
resLogNormL <- A[,(1:9) + 27]
resLogNormU <- A[,(1:9) + 36]

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- 
  colnames(resLogNormL) <- colnames(resLogNormU) <- c(
    "correct_data", "ztoipoisson_split", "Hurdleztpoisson_split", 
    "oiztpoisson_split", "ztHurdlepoisson_split", "ztoipoisson_combined", 
    "Hurdleztpoisson_combined", "oiztpoisson_combined", "ztHurdlepoisson_combined"
  )

print("ztoipoisson")
summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/ztoipoisson_linkage_error_point_est")
write.csv(resNormL, file = "results/ztoipoisson_linkage_error_normalL")
write.csv(resNormU, file = "results/ztoipoisson_linkage_error_normalU")
write.csv(resLogNormL, file = "results/ztoipoisson_linkage_error_log_normalL")
write.csv(resLogNormU, file = "results/ztoipoisson_linkage_error_log_normalU")

##### counts generated by oiztpoisson #####
fn <- oiztpoisson()
fn1 <- Hurdleztpoisson()
fn2 <- ztoipoisson()
fn3 <- ztHurdlepoisson()

cl <- makeCluster(cores)
clusterExport(cl, c("N", "sims", "fn", "fn1", "fn2", "fn3"))
registerDoParallel(cl)

A <- foreach(k=1:sims, .combine = rbind, .packages = c("singleRcapture", "igraph")) %dopar% {
  x1 <- rnorm(n = N)
  x2 <- rnorm(n = N)
  x3 <- rnorm(n = N)
  x4 <- rnorm(n = N)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8),
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8)
  )
  
  y <- simulate(fn, eta = eta)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  # spliting
  iddx <- sample(which(df$y > 1), size = .03*NROW(df))
  dddd <- df
  for (k in iddx) {
    M <- dddd[k, ]
    dddd <- dddd[-k, ]
    
    yy <- vector(mode = "numeric")
    while (sum(yy) < M[,"y"][[1]]) {
      yy[length(yy) + 1] <- sample(size = 1, x = 1:(M[,"y"][[1]]-sum(yy)))
    }
    
    dddd[NROW(dddd)+1:length(yy), ] <- cbind(yy, t(sapply(1:length(yy), FUN = function(x) M[,-1]))) |> as.data.frame()
  }
  
  dddd <- sapply(dddd, FUN = unlist) |> as.data.frame()
  
  # combining
  rownames(df) <- 1:NROW(df)
  iddx1 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  iddx2 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  
  graph <- graph_from_data_frame(d = data.frame(iddx1, iddx2), directed=FALSE)
  cmp <- components(graph)
  cliques <- cmp$membership |> unique()
  cliques <- lapply(cliques, function (x) names(which(cmp$membership == x)))
  
  dddd1 <- df
  for (k in cliques) {
    M <- dddd1[k, ]
    dddd1 <- dddd1[!(rownames(dddd1) %in% k), ]
    
    dddd[NROW(dddd1)+1, ] <- colSums(M) / c(1, rep(NROW(M), NCOL(M) - 1))
  }
  
  dddd1 <- sapply(dddd1, FUN = unlist) |> as.data.frame()
  
  M_true <- NULL
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  
  R  <- NULL
  R1 <- NULL
  R2 <- NULL
  R3 <- NULL
  
  try(
    M_true <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    )
  )
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  rbind(c(
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
  ))
}

stopCluster(cl)

resPoint    <- A[,1:9]
resNormL    <- A[,(1:9) + 9]
resNormU    <- A[,(1:9) + 18]
resLogNormL <- A[,(1:9) + 27]
resLogNormU <- A[,(1:9) + 36]

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- 
  colnames(resLogNormL) <- colnames(resLogNormU) <- c(
    "correct_data", "oiztpoisson_split", "Hurdleztpoisson_split", 
    "ztoipoisson_split", "ztHurdlepoisson_split", "oiztpoisson_combined", 
    "Hurdleztpoisson_combined", "ztoipoisson_combined", "ztHurdlepoisson_combined"
  )

print("oiztpoisson")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/oiztpoisson_linkage_error_point_est")
write.csv(resNormL, file = "results/oiztpoisson_linkage_error_normalL")
write.csv(resNormU, file = "results/oiztpoisson_linkage_error_normalU")
write.csv(resLogNormL, file = "results/oiztpoisson_linkage_error_log_normalL")
write.csv(resLogNormU, file = "results/oiztpoisson_linkage_error_log_normalU")

##### counts generated by ztHurdlepoisson #####
fn <- ztHurdlepoisson()
fn1 <- Hurdleztpoisson()
fn2 <- ztoipoisson()
fn3 <- oiztpoisson()

cl <- makeCluster(cores)
clusterExport(cl, c("N", "sims", "fn", "fn1", "fn2", "fn3"))
registerDoParallel(cl)

A <- foreach(k=1:sims, .combine = rbind, .packages = c("singleRcapture", "igraph")) %dopar% {
  x1 <- rnorm(n = N)
  x2 <- rnorm(n = N)
  x3 <- rnorm(n = N)
  x4 <- rnorm(n = N)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8),
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8)
  )
  
  y <- simulate(fn, eta = eta)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  # spliting
  iddx <- sample(which(df$y > 1), size = .03*NROW(df))
  dddd <- df
  for (k in iddx) {
    M <- dddd[k, ]
    dddd <- dddd[-k, ]
    
    yy <- vector(mode = "numeric")
    while (sum(yy) < M[,"y"][[1]]) {
      yy[length(yy) + 1] <- sample(size = 1, x = 1:(M[,"y"][[1]]-sum(yy)))
    }
    
    dddd[NROW(dddd)+1:length(yy), ] <- cbind(yy, t(sapply(1:length(yy), FUN = function(x) M[,-1]))) |> as.data.frame()
  }
  
  dddd <- sapply(dddd, FUN = unlist) |> as.data.frame()
  
  # combining
  rownames(df) <- 1:NROW(df)
  iddx1 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  iddx2 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  
  graph <- graph_from_data_frame(d = data.frame(iddx1, iddx2), directed=FALSE)
  cmp <- components(graph)
  cliques <- cmp$membership |> unique()
  cliques <- lapply(cliques, function (x) names(which(cmp$membership == x)))
  
  dddd1 <- df
  for (k in cliques) {
    M <- dddd1[k, ]
    dddd1 <- dddd1[!(rownames(dddd1) %in% k), ]
    
    dddd[NROW(dddd1)+1, ] <- colSums(M) / c(1, rep(NROW(M), NCOL(M) - 1))
  }
  
  dddd1 <- sapply(dddd1, FUN = unlist) |> as.data.frame()
  
  
  M_true <- NULL
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  
  R  <- NULL
  R1 <- NULL
  R2 <- NULL
  R3 <- NULL
  
  try(
    M_true <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    )
  )
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  rbind(c(
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
  ))
}

stopCluster(cl)

resPoint    <- A[,1:9]
resNormL    <- A[,(1:9) + 9]
resNormU    <- A[,(1:9) + 18]
resLogNormL <- A[,(1:9) + 27]
resLogNormU <- A[,(1:9) + 36]

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- 
  colnames(resLogNormL) <- colnames(resLogNormU) <- c(
    "correct_data", "ztHurdlepoisson_split", "Hurdleztpoisson_split", 
    "ztoipoisson_split", "oiztpoisson_split", "ztHurdlepoisson_combined", 
    "Hurdleztpoisson_combined", "ztoipoisson_combined", "oiztpoisson_combined"
  )

print("ztHurdlepoisson")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/ztHurdletpoisson_linkage_error_point_est")
write.csv(resNormL, file = "results/ztHurdlepoisson_linkage_error_normalL")
write.csv(resNormU, file = "results/ztHurdlepoisson_linkage_error_normalU")
write.csv(resLogNormL, file = "results/ztHurdlepoisson_linkage_error_log_normalL")
write.csv(resLogNormU, file = "results/ztHurdlepoisson_linkage_error_log_normalU")

##### counts generated by Hurdleztpoisson #####
fn <- Hurdleztpoisson()
fn1 <- oiztpoisson()
fn2 <- ztoipoisson()
fn3 <- ztHurdlepoisson()

cl <- makeCluster(cores)
clusterExport(cl, c("N", "sims", "fn", "fn1", "fn2", "fn3"))
registerDoParallel(cl)

A <- foreach(k=1:sims, .combine = rbind, .packages = c("singleRcapture", "igraph")) %dopar% {
  x1 <- rnorm(n = N)
  x2 <- rnorm(n = N)
  x3 <- rnorm(n = N)
  x4 <- rnorm(n = N)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8),
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8)
  )
  
  y <- simulate(fn, eta = eta)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  # spliting
  iddx <- sample(which(df$y > 1), size = .03*NROW(df))
  dddd <- df
  for (k in iddx) {
    M <- dddd[k, ]
    dddd <- dddd[-k, ]
    
    yy <- vector(mode = "numeric")
    while (sum(yy) < M[,"y"][[1]]) {
      yy[length(yy) + 1] <- sample(size = 1, x = 1:(M[,"y"][[1]]-sum(yy)))
    }
    
    dddd[NROW(dddd)+1:length(yy), ] <- cbind(yy, t(sapply(1:length(yy), FUN = function(x) M[,-1]))) |> as.data.frame()
  }
  
  dddd <- sapply(dddd, FUN = unlist) |> as.data.frame()
  
  # combining
  rownames(df) <- 1:NROW(df)
  iddx1 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  iddx2 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  
  graph <- graph_from_data_frame(d = data.frame(iddx1, iddx2), directed=FALSE)
  cmp <- components(graph)
  cliques <- cmp$membership |> unique()
  cliques <- lapply(cliques, function (x) names(which(cmp$membership == x)))
  
  dddd1 <- df
  for (k in cliques) {
    M <- dddd1[k, ]
    dddd1 <- dddd1[!(rownames(dddd1) %in% k), ]
    
    dddd[NROW(dddd1)+1, ] <- colSums(M) / c(1, rep(NROW(M), NCOL(M) - 1))
  }
  
  dddd1 <- sapply(dddd1, FUN = unlist) |> as.data.frame()
  
  M_true <- NULL
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  
  R  <- NULL
  R1 <- NULL
  R2 <- NULL
  R3 <- NULL
  
  try(
    M_true <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    )
  )
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  rbind(c(
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
  ))
}

stopCluster(cl)

resPoint    <- A[,1:9]
resNormL    <- A[,(1:9) + 9]
resNormU    <- A[,(1:9) + 18]
resLogNormL <- A[,(1:9) + 27]
resLogNormU <- A[,(1:9) + 36]

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- 
  colnames(resLogNormL) <- colnames(resLogNormU) <- c(
    "correct_data", "Hurdleztpoisson_split", "oiztpoisson_split", 
    "ztoipoisson_split", "ztHurdlepoisson_split", "Hurdleztpoisson_combined", 
    "oiztpoisson_combined", "ztoipoisson_combined", "ztHurdlepoisson_combined"
  )

print("Hurdleztpoisson")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/Hurdleztpoisson_linkage_error_point_est")
write.csv(resNormL, file = "results/Hurdleztpoisson_linkage_error_normalL")
write.csv(resNormU, file = "results/Hurdleztpoisson_linkage_error_normalU")
write.csv(resLogNormL, file = "results/Hurdleztpoisson_linkage_error_log_normalL")
write.csv(resLogNormU, file = "results/Hurdleztpoisson_linkage_error_log_normalU")


##### counts generated by ztoigeom ####
# send model info to each core
# pop size
N <- 2500
sims <- 500

fn <- ztoigeom()
fn1 <- Hurdleztgeom()
fn2 <- oiztgeom()
fn3 <- ztHurdlegeom()

cl <- makeCluster(cores)
clusterExport(cl, c("N", "sims", "fn", "fn1", "fn2", "fn3"))
registerDoParallel(cl)

A <- foreach(k=1:sims, .combine = rbind, .packages = c("singleRcapture", "igraph")) %dopar% {
  x1 <- rnorm(n = N)
  x2 <- rnorm(n = N)
  x3 <- rnorm(n = N)
  x4 <- rnorm(n = N)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8),
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8)
  )
  
  y <- simulate(fn, eta = eta)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  # spliting
  iddx <- sample(which(df$y > 1), size = .03*NROW(df))
  dddd <- df
  for (k in iddx) {
    M <- dddd[k, ]
    dddd <- dddd[-k, ]
    
    yy <- vector(mode = "numeric")
    while (sum(yy) < M[,"y"][[1]]) {
      yy[length(yy) + 1] <- sample(size = 1, x = 1:(M[,"y"][[1]]-sum(yy)))
    }
    
    dddd[NROW(dddd)+1:length(yy), ] <- cbind(yy, t(sapply(1:length(yy), FUN = function(x) M[,-1]))) |> as.data.frame()
  }
  
  dddd <- sapply(dddd, FUN = unlist) |> as.data.frame()
  
  # combining
  rownames(df) <- 1:NROW(df)
  iddx1 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  iddx2 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  
  graph <- graph_from_data_frame(d = data.frame(iddx1, iddx2), directed=FALSE)
  cmp <- components(graph)
  cliques <- cmp$membership |> unique()
  cliques <- lapply(cliques, function (x) names(which(cmp$membership == x)))
  
  dddd1 <- df
  for (k in cliques) {
    M <- dddd1[k, ]
    dddd1 <- dddd1[!(rownames(dddd1) %in% k), ]
    
    dddd[NROW(dddd1)+1, ] <- colSums(M) / c(1, rep(NROW(M), NCOL(M) - 1))
  }
  
  dddd1 <- sapply(dddd1, FUN = unlist) |> as.data.frame()
  
  M_true <- NULL
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  
  R  <- NULL
  R1 <- NULL
  R2 <- NULL
  R3 <- NULL
  
  try(
    M_true <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    )
  )
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  rbind(c(
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
  ))
}

stopCluster(cl)

resPoint    <- A[,1:9]
resNormL    <- A[,(1:9) + 9]
resNormU    <- A[,(1:9) + 18]
resLogNormL <- A[,(1:9) + 27]
resLogNormU <- A[,(1:9) + 36]

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- 
  colnames(resLogNormL) <- colnames(resLogNormU) <- c(
    "correct_data", "ztoigeom_split", "Hurdleztgeom_split", 
    "oiztgeom_split", "ztHurdlegeom_split", "ztoigeom_combined", 
    "Hurdleztgeom_combined", "oiztgeom_combined", "ztHurdlegeom_combined"
  )

print("")

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/ztoigeom_linkage_error_point_est")
write.csv(resNormL, file = "results/ztoigeom_linkage_error_normalL")
write.csv(resNormU, file = "results/ztoigeom_linkage_error_normalU")
write.csv(resLogNormL, file = "results/ztoigeom_linkage_error_log_normalL")
write.csv(resLogNormU, file = "results/ztoigeom_linkage_error_log_normalU")

##### counts generated by oiztgeom #####
fn <- oiztgeom()
fn1 <- Hurdleztgeom()
fn2 <- ztoigeom()
fn3 <- ztHurdlegeom()

cl <- makeCluster(cores)
clusterExport(cl, c("N", "sims", "fn", "fn1", "fn2", "fn3"))
registerDoParallel(cl)

A <- foreach(k=1:sims, .combine = rbind, .packages = c("singleRcapture", "igraph")) %dopar% {
  x1 <- rnorm(n = N)
  x2 <- rnorm(n = N)
  x3 <- rnorm(n = N)
  x4 <- rnorm(n = N)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8),
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8)
  )
  
  y <- simulate(fn, eta = eta)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  # spliting
  iddx <- sample(which(df$y > 1), size = .03*NROW(df))
  dddd <- df
  for (k in iddx) {
    M <- dddd[k, ]
    dddd <- dddd[-k, ]
    
    yy <- vector(mode = "numeric")
    while (sum(yy) < M[,"y"][[1]]) {
      yy[length(yy) + 1] <- sample(size = 1, x = 1:(M[,"y"][[1]]-sum(yy)))
    }
    
    dddd[NROW(dddd)+1:length(yy), ] <- cbind(yy, t(sapply(1:length(yy), FUN = function(x) M[,-1]))) |> as.data.frame()
  }
  
  dddd <- sapply(dddd, FUN = unlist) |> as.data.frame()
  
  # combining
  rownames(df) <- 1:NROW(df)
  iddx1 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  iddx2 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  
  graph <- graph_from_data_frame(d = data.frame(iddx1, iddx2), directed=FALSE)
  cmp <- components(graph)
  cliques <- cmp$membership |> unique()
  cliques <- lapply(cliques, function (x) names(which(cmp$membership == x)))
  
  dddd1 <- df
  for (k in cliques) {
    M <- dddd1[k, ]
    dddd1 <- dddd1[!(rownames(dddd1) %in% k), ]
    
    dddd[NROW(dddd1)+1, ] <- colSums(M) / c(1, rep(NROW(M), NCOL(M) - 1))
  }
  
  dddd1 <- sapply(dddd1, FUN = unlist) |> as.data.frame()
  
  M_true <- NULL
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  
  R  <- NULL
  R1 <- NULL
  R2 <- NULL
  R3 <- NULL
  
  try(
    M_true <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    )
  )
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  rbind(c(
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
  ))
}

stopCluster(cl)

resPoint    <- A[,1:9]
resNormL    <- A[,(1:9) + 9]
resNormU    <- A[,(1:9) + 18]
resLogNormL <- A[,(1:9) + 27]
resLogNormU <- A[,(1:9) + 36]

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- 
  colnames(resLogNormL) <- colnames(resLogNormU) <- c(
    "correct_data", "oiztgeom_split", "Hurdleztgeom_split", 
    "ztoigeom_split", "ztHurdlegeom_split", "oiztgeom_combined", 
    "Hurdleztgeom_combined", "ztoigeom_combined", "ztHurdlegeom_combined"
  )

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/oiztgeom_linkage_error_point_est")
write.csv(resNormL, file = "results/oiztgeom_linkage_error_normalL")
write.csv(resNormU, file = "results/oiztgeom_linkage_error_normalU")
write.csv(resLogNormL, file = "results/oiztgeom_linkage_error_log_normalL")
write.csv(resLogNormU, file = "results/oiztgeom_linkage_error_log_normalU")

##### counts generated by ztHurdlegeom #####
fn <- ztHurdlegeom()
fn1 <- Hurdleztgeom()
fn2 <- ztoigeom()
fn3 <- oiztgeom()

cl <- makeCluster(cores)
clusterExport(cl, c("N", "sims", "fn", "fn1", "fn2", "fn3"))
registerDoParallel(cl)

A <- foreach(k=1:sims, .combine = rbind, .packages = c("singleRcapture", "igraph")) %dopar% {
  x1 <- rnorm(n = N)
  x2 <- rnorm(n = N)
  x3 <- rnorm(n = N)
  x4 <- rnorm(n = N)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8),
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8)
  )
  
  y <- simulate(fn, eta = eta)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  # spliting
  iddx <- sample(which(df$y > 1), size = .03*NROW(df))
  dddd <- df
  for (k in iddx) {
    M <- dddd[k, ]
    dddd <- dddd[-k, ]
    
    yy <- vector(mode = "numeric")
    while (sum(yy) < M[,"y"][[1]]) {
      yy[length(yy) + 1] <- sample(size = 1, x = 1:(M[,"y"][[1]]-sum(yy)))
    }
    
    dddd[NROW(dddd)+1:length(yy), ] <- cbind(yy, t(sapply(1:length(yy), FUN = function(x) M[,-1]))) |> as.data.frame()
  }
  
  dddd <- sapply(dddd, FUN = unlist) |> as.data.frame()
  
  # combining
  rownames(df) <- 1:NROW(df)
  iddx1 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  iddx2 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  
  graph <- graph_from_data_frame(d = data.frame(iddx1, iddx2), directed=FALSE)
  cmp <- components(graph)
  cliques <- cmp$membership |> unique()
  cliques <- lapply(cliques, function (x) names(which(cmp$membership == x)))
  
  dddd1 <- df
  for (k in cliques) {
    M <- dddd1[k, ]
    dddd1 <- dddd1[!(rownames(dddd1) %in% k), ]
    
    dddd[NROW(dddd1)+1, ] <- colSums(M) / c(1, rep(NROW(M), NCOL(M) - 1))
  }
  
  dddd1 <- sapply(dddd1, FUN = unlist) |> as.data.frame()
  
  
  M_true <- NULL
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  
  R  <- NULL
  R1 <- NULL
  R2 <- NULL
  R3 <- NULL
  
  try(
    M_true <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    )
  )
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  rbind(c(
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
  ))
}

stopCluster(cl)

resPoint    <- A[,1:9]
resNormL    <- A[,(1:9) + 9]
resNormU    <- A[,(1:9) + 18]
resLogNormL <- A[,(1:9) + 27]
resLogNormU <- A[,(1:9) + 36]

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- 
  colnames(resLogNormL) <- colnames(resLogNormU) <- c(
    "correct_data", "ztHurdlegeom_split", "Hurdleztgeom_split", 
    "ztoigeom_split", "oiztgeom_split", "ztHurdlegeom_combined", 
    "Hurdleztgeom_combined", "ztoigeom_combined", "oiztgeom_combined"
  )

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/ztHurdletgeom_linkage_error_point_est")
write.csv(resNormL, file = "results/ztHurdlegeom_linkage_error_normalL")
write.csv(resNormU, file = "results/ztHurdlegeom_linkage_error_normalU")
write.csv(resLogNormL, file = "results/ztHurdlegeom_linkage_error_log_normalL")
write.csv(resLogNormU, file = "results/ztHurdlegeom_linkage_error_log_normalU")

##### counts generated by Hurdleztgeom #####
fn <- Hurdleztgeom()
fn1 <- oiztgeom()
fn2 <- ztoigeom()
fn3 <- ztHurdlegeom()

cl <- makeCluster(cores)
clusterExport(cl, c("N", "sims", "fn", "fn1", "fn2", "fn3"))
registerDoParallel(cl)

A <- foreach(k=1:sims, .combine = rbind, .packages = c("singleRcapture", "igraph")) %dopar% {
  x1 <- rnorm(n = N)
  x2 <- rnorm(n = N)
  x3 <- rnorm(n = N)
  x4 <- rnorm(n = N)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8),
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8)
  )
  
  y <- simulate(fn, eta = eta)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  # spliting
  iddx <- sample(which(df$y > 1), size = .03*NROW(df))
  dddd <- df
  for (k in iddx) {
    M <- dddd[k, ]
    dddd <- dddd[-k, ]
    
    yy <- vector(mode = "numeric")
    while (sum(yy) < M[,"y"][[1]]) {
      yy[length(yy) + 1] <- sample(size = 1, x = 1:(M[,"y"][[1]]-sum(yy)))
    }
    
    dddd[NROW(dddd)+1:length(yy), ] <- cbind(yy, t(sapply(1:length(yy), FUN = function(x) M[,-1]))) |> as.data.frame()
  }
  
  dddd <- sapply(dddd, FUN = unlist) |> as.data.frame()
  
  # combining
  rownames(df) <- 1:NROW(df)
  iddx1 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  iddx2 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  
  graph <- graph_from_data_frame(d = data.frame(iddx1, iddx2), directed=FALSE)
  cmp <- components(graph)
  cliques <- cmp$membership |> unique()
  cliques <- lapply(cliques, function (x) names(which(cmp$membership == x)))
  
  dddd1 <- df
  for (k in cliques) {
    M <- dddd1[k, ]
    dddd1 <- dddd1[!(rownames(dddd1) %in% k), ]
    
    dddd[NROW(dddd1)+1, ] <- colSums(M) / c(1, rep(NROW(M), NCOL(M) - 1))
  }
  
  dddd1 <- sapply(dddd1, FUN = unlist) |> as.data.frame()
  
  M_true <- NULL
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  
  R  <- NULL
  R1 <- NULL
  R2 <- NULL
  R3 <- NULL
  
  try(
    M_true <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    )
  )
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  rbind(c(
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
  ))
}

stopCluster(cl)

resPoint    <- A[,1:9]
resNormL    <- A[,(1:9) + 9]
resNormU    <- A[,(1:9) + 18]
resLogNormL <- A[,(1:9) + 27]
resLogNormU <- A[,(1:9) + 36]

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- 
  colnames(resLogNormL) <- colnames(resLogNormU) <- c(
    "correct_data", "Hurdleztgeom_split", "oiztgeom_split", 
    "ztoigeom_split", "ztHurdlegeom_split", "Hurdleztgeom_combined", 
    "oiztgeom_combined", "ztoigeom_combined", "ztHurdlegeom_combined"
  )

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/Hurdleztgeom_linkage_error_point_est")
write.csv(resNormL, file = "results/Hurdleztgeom_linkage_error_normalL")
write.csv(resNormU, file = "results/Hurdleztgeom_linkage_error_normalU")
write.csv(resLogNormL, file = "results/Hurdleztgeom_linkage_error_log_normalL")
write.csv(resLogNormU, file = "results/Hurdleztgeom_linkage_error_log_normalU")


##### counts generated by ztoinegbin ####
# send model info to each core
# pop size
N <- 2500
sims <- 500

fn <- ztoinegbin()
fn1 <- Hurdleztnegbin()
fn2 <- oiztnegbin()
fn3 <- ztHurdlenegbin()

cl <- makeCluster(cores)
clusterExport(cl, c("N", "sims", "fn", "fn1", "fn2", "fn3"))
registerDoParallel(cl)

A <- foreach(k=1:sims, .combine = rbind, .packages = c("singleRcapture", "igraph")) %dopar% {
  x1 <- rnorm(n = N)
  x2 <- rnorm(n = N)
  x3 <- rnorm(n = N)
  x4 <- rnorm(n = N)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8),
    log(runif(n=1, max = .75, min = .45)),
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8)
  )
  
  y <- simulate(fn, eta = eta)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  # spliting
  iddx <- sample(which(df$y > 1), size = .03*NROW(df))
  dddd <- df
  for (k in iddx) {
    M <- dddd[k, ]
    dddd <- dddd[-k, ]
    
    yy <- vector(mode = "numeric")
    while (sum(yy) < M[,"y"][[1]]) {
      yy[length(yy) + 1] <- sample(size = 1, x = 1:(M[,"y"][[1]]-sum(yy)))
    }
    
    dddd[NROW(dddd)+1:length(yy), ] <- cbind(yy, t(sapply(1:length(yy), FUN = function(x) M[,-1]))) |> as.data.frame()
  }
  
  dddd <- sapply(dddd, FUN = unlist) |> as.data.frame()
  
  # combining
  rownames(df) <- 1:NROW(df)
  iddx1 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  iddx2 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  
  graph <- graph_from_data_frame(d = data.frame(iddx1, iddx2), directed=FALSE)
  cmp <- components(graph)
  cliques <- cmp$membership |> unique()
  cliques <- lapply(cliques, function (x) names(which(cmp$membership == x)))
  
  dddd1 <- df
  for (k in cliques) {
    M <- dddd1[k, ]
    dddd1 <- dddd1[!(rownames(dddd1) %in% k), ]
    
    dddd[NROW(dddd1)+1, ] <- colSums(M) / c(1, rep(NROW(M), NCOL(M) - 1))
  }
  
  dddd1 <- sapply(dddd1, FUN = unlist) |> as.data.frame()
  
  M_true <- NULL
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  
  R  <- NULL
  R1 <- NULL
  R2 <- NULL
  R3 <- NULL
  
  try(
    M_true <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  rbind(c(
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
  ))
}

stopCluster(cl)

resPoint    <- A[,1:9]
resNormL    <- A[,(1:9) + 9]
resNormU    <- A[,(1:9) + 18]
resLogNormL <- A[,(1:9) + 27]
resLogNormU <- A[,(1:9) + 36]

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- 
  colnames(resLogNormL) <- colnames(resLogNormU) <- c(
    "correct_data", "ztoinegbin_split", "Hurdleztnegbin_split", 
    "oiztnegbin_split", "ztHurdlenegbin_split", "ztoinegbin_combined", 
    "Hurdleztnegbin_combined", "oiztnegbin_combined", "ztHurdlenegbin_combined"
  )

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/ztoinegbin_linkage_error_point_est")
write.csv(resNormL, file = "results/ztoinegbin_linkage_error_normalL")
write.csv(resNormU, file = "results/ztoinegbin_linkage_error_normalU")
write.csv(resLogNormL, file = "results/ztoinegbin_linkage_error_log_normalL")
write.csv(resLogNormU, file = "results/ztoinegbin_linkage_error_log_normalU")

##### counts generated by oiztnegbin #####
fn <- oiztnegbin()
fn1 <- Hurdleztnegbin()
fn2 <- ztoinegbin()
fn3 <- ztHurdlenegbin()

cl <- makeCluster(cores)
clusterExport(cl, c("N", "sims", "fn", "fn1", "fn2", "fn3"))
registerDoParallel(cl)

A <- foreach(k=1:sims, .combine = rbind, .packages = c("singleRcapture", "igraph")) %dopar% {
  x1 <- rnorm(n = N)
  x2 <- rnorm(n = N)
  x3 <- rnorm(n = N)
  x4 <- rnorm(n = N)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8),
    log(runif(n=1, max = .75, min = .45)),
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8)
  )
  
  y <- simulate(fn, eta = eta)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  # spliting
  iddx <- sample(which(df$y > 1), size = .03*NROW(df))
  dddd <- df
  for (k in iddx) {
    M <- dddd[k, ]
    dddd <- dddd[-k, ]
    
    yy <- vector(mode = "numeric")
    while (sum(yy) < M[,"y"][[1]]) {
      yy[length(yy) + 1] <- sample(size = 1, x = 1:(M[,"y"][[1]]-sum(yy)))
    }
    
    dddd[NROW(dddd)+1:length(yy), ] <- cbind(yy, t(sapply(1:length(yy), FUN = function(x) M[,-1]))) |> as.data.frame()
  }
  
  dddd <- sapply(dddd, FUN = unlist) |> as.data.frame()
  
  # combining
  rownames(df) <- 1:NROW(df)
  iddx1 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  iddx2 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  
  graph <- graph_from_data_frame(d = data.frame(iddx1, iddx2), directed=FALSE)
  cmp <- components(graph)
  cliques <- cmp$membership |> unique()
  cliques <- lapply(cliques, function (x) names(which(cmp$membership == x)))
  
  dddd1 <- df
  for (k in cliques) {
    M <- dddd1[k, ]
    dddd1 <- dddd1[!(rownames(dddd1) %in% k), ]
    
    dddd[NROW(dddd1)+1, ] <- colSums(M) / c(1, rep(NROW(M), NCOL(M) - 1))
  }
  
  dddd1 <- sapply(dddd1, FUN = unlist) |> as.data.frame()
  
  M_true <- NULL
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  
  R  <- NULL
  R1 <- NULL
  R2 <- NULL
  R3 <- NULL
  
  try(
    M_true <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    )
  )
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  rbind(c(
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
  ))
}

stopCluster(cl)

resPoint    <- A[,1:9]
resNormL    <- A[,(1:9) + 9]
resNormU    <- A[,(1:9) + 18]
resLogNormL <- A[,(1:9) + 27]
resLogNormU <- A[,(1:9) + 36]

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- 
  colnames(resLogNormL) <- colnames(resLogNormU) <- c(
    "correct_data", "oiztnegbin_split", "Hurdleztnegbin_split", 
    "ztoinegbin_split", "ztHurdlenegbin_split", "oiztnegbin_combined", 
    "Hurdleztnegbin_combined", "ztoinegbin_combined", "ztHurdlenegbin_combined"
  )

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/oiztnegbin_linkage_error_point_est")
write.csv(resNormL, file = "results/oiztnegbin_linkage_error_normalL")
write.csv(resNormU, file = "results/oiztnegbin_linkage_error_normalU")
write.csv(resLogNormL, file = "results/oiztnegbin_linkage_error_log_normalL")
write.csv(resLogNormU, file = "results/oiztnegbin_linkage_error_log_normalU")

##### counts generated by ztHurdlenegbin #####
fn <- ztHurdlenegbin()
fn1 <- Hurdleztnegbin()
fn2 <- ztoinegbin()
fn3 <- oiztnegbin()

cl <- makeCluster(cores)
clusterExport(cl, c("N", "sims", "fn", "fn1", "fn2", "fn3"))
registerDoParallel(cl)

A <- foreach(k=1:sims, .combine = rbind, .packages = c("singleRcapture", "igraph")) %dopar% {
  x1 <- rnorm(n = N)
  x2 <- rnorm(n = N)
  x3 <- rnorm(n = N)
  x4 <- rnorm(n = N)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8),
    log(runif(n=1, max = .75, min = .45)),
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8)
  )
  
  y <- simulate(fn, eta = eta)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  # spliting
  iddx <- sample(which(df$y > 1), size = .03*NROW(df))
  dddd <- df
  for (k in iddx) {
    M <- dddd[k, ]
    dddd <- dddd[-k, ]
    
    yy <- vector(mode = "numeric")
    while (sum(yy) < M[,"y"][[1]]) {
      yy[length(yy) + 1] <- sample(size = 1, x = 1:(M[,"y"][[1]]-sum(yy)))
    }
    
    dddd[NROW(dddd)+1:length(yy), ] <- cbind(yy, t(sapply(1:length(yy), FUN = function(x) M[,-1]))) |> as.data.frame()
  }
  
  dddd <- sapply(dddd, FUN = unlist) |> as.data.frame()
  
  # combining
  rownames(df) <- 1:NROW(df)
  iddx1 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  iddx2 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  
  graph <- graph_from_data_frame(d = data.frame(iddx1, iddx2), directed=FALSE)
  cmp <- components(graph)
  cliques <- cmp$membership |> unique()
  cliques <- lapply(cliques, function (x) names(which(cmp$membership == x)))
  
  dddd1 <- df
  for (k in cliques) {
    M <- dddd1[k, ]
    dddd1 <- dddd1[!(rownames(dddd1) %in% k), ]
    
    dddd[NROW(dddd1)+1, ] <- colSums(M) / c(1, rep(NROW(M), NCOL(M) - 1))
  }
  
  dddd1 <- sapply(dddd1, FUN = unlist) |> as.data.frame()
  
  
  M_true <- NULL
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  
  R  <- NULL
  R1 <- NULL
  R2 <- NULL
  R3 <- NULL
  
  try(
    M_true <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    )
  )
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  rbind(c(
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
  ))
}

stopCluster(cl)

resPoint    <- A[,1:9]
resNormL    <- A[,(1:9) + 9]
resNormU    <- A[,(1:9) + 18]
resLogNormL <- A[,(1:9) + 27]
resLogNormU <- A[,(1:9) + 36]

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- 
  colnames(resLogNormL) <- colnames(resLogNormU) <- c(
    "correct_data", "ztHurdlenegbin_split", "Hurdleztnegbin_split", 
    "ztoinegbin_split", "oiztnegbin_split", "ztHurdlenegbin_combined", 
    "Hurdleztnegbin_combined", "ztoinegbin_combined", "oiztnegbin_combined"
  )

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/ztHurdletnegbin_linkage_error_point_est")
write.csv(resNormL, file = "results/ztHurdlenegbin_linkage_error_normalL")
write.csv(resNormU, file = "results/ztHurdlenegbin_linkage_error_normalU")
write.csv(resLogNormL, file = "results/ztHurdlenegbin_linkage_error_log_normalL")
write.csv(resLogNormU, file = "results/ztHurdlenegbin_linkage_error_log_normalU")

##### counts generated by Hurdleztnegbin #####
fn <- Hurdleztnegbin()
fn1 <- oiztnegbin()
fn2 <- ztoinegbin()
fn3 <- ztHurdlenegbin()

cl <- makeCluster(cores)
clusterExport(cl, c("N", "sims", "fn", "fn1", "fn2", "fn3"))
registerDoParallel(cl)

A <- foreach(k=1:sims, .combine = rbind, .packages = c("singleRcapture", "igraph")) %dopar% {
  x1 <- rnorm(n = N)
  x2 <- rnorm(n = N)
  x3 <- rnorm(n = N)
  x4 <- rnorm(n = N)
  eta <- cbind(
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8),
    log(runif(n=1, max = .75, min = .45)),
    cbind(1, x1, x2, x3, x4) %*% runif(n=5, max = .8)
  )
  
  y <- simulate(fn, eta = eta)
  
  df <- data.frame(
    y = y, x1 = x1, x2 = x2, x3 = x3, x4 = x4
  )
  
  df <- df[df$y>0, ]
  
  # spliting
  iddx <- sample(which(df$y > 1), size = .03*NROW(df))
  dddd <- df
  for (k in iddx) {
    M <- dddd[k, ]
    dddd <- dddd[-k, ]
    
    yy <- vector(mode = "numeric")
    while (sum(yy) < M[,"y"][[1]]) {
      yy[length(yy) + 1] <- sample(size = 1, x = 1:(M[,"y"][[1]]-sum(yy)))
    }
    
    dddd[NROW(dddd)+1:length(yy), ] <- cbind(yy, t(sapply(1:length(yy), FUN = function(x) M[,-1]))) |> as.data.frame()
  }
  
  dddd <- sapply(dddd, FUN = unlist) |> as.data.frame()
  
  # combining
  rownames(df) <- 1:NROW(df)
  iddx1 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  iddx2 <- sample(1:NROW(df$y), size = .0125*NROW(df), replace = TRUE)
  
  graph <- graph_from_data_frame(d = data.frame(iddx1, iddx2), directed=FALSE)
  cmp <- components(graph)
  cliques <- cmp$membership |> unique()
  cliques <- lapply(cliques, function (x) names(which(cmp$membership == x)))
  
  dddd1 <- df
  for (k in cliques) {
    M <- dddd1[k, ]
    dddd1 <- dddd1[!(rownames(dddd1) %in% k), ]
    
    dddd[NROW(dddd1)+1, ] <- colSums(M) / c(1, rep(NROW(M), NCOL(M) - 1))
  }
  
  dddd1 <- sapply(dddd1, FUN = unlist) |> as.data.frame()
  
  M_true <- NULL
  
  M  <- NULL
  M1 <- NULL
  M2 <- NULL
  M3 <- NULL
  
  R  <- NULL
  R1 <- NULL
  R2 <- NULL
  R3 <- NULL
  
  try(
    M_true <- estimatePopsize(
      formula = y ~ .,
      data = df,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    )
  )
  
  try(
    M <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    M3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R1 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn1,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R2 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn2,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  try(
    R3 <- estimatePopsize(
      formula = y ~ .,
      data = dddd1,
      model = fn3,
      controlModel = controlModel(
        piFormula    = ~ .,
        omegaFormula = ~ .
      ),
      controlMethod = controlMethod(
        silent = TRUE,
        # more stability hand picked
        stepsize = .8
      )
    ),
    silent = TRUE
  )
  
  rbind(c(
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$pointEstimate}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[1,2]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,1]}),
    sapply(list(M_true, M, M1, M2, M3, R, R1, R2, R3), FUN = function(x) {if (is.null(x)) NA else popSizeEst(x)$confidenceInterval[2,2]})
  ))
}

stopCluster(cl)

resPoint    <- A[,1:9]
resNormL    <- A[,(1:9) + 9]
resNormU    <- A[,(1:9) + 18]
resLogNormL <- A[,(1:9) + 27]
resLogNormU <- A[,(1:9) + 36]

colnames(resPoint) <- colnames(resNormL) <- colnames(resNormU) <- 
  colnames(resLogNormL) <- colnames(resLogNormU) <- c(
    "correct_data", "Hurdleztnegbin_split", "oiztnegbin_split", 
    "ztoinegbin_split", "ztHurdlenegbin_split", "Hurdleztnegbin_combined", 
    "oiztnegbin_combined", "ztoinegbin_combined", "ztHurdlenegbin_combined"
  )

summary(resPoint-N)
sapply(as.data.frame(resPoint - N), function (x) mean(x, na.rm = TRUE))
summary((resPoint-N)^2)
sapply(as.data.frame((resPoint - N)^2), function (x) mean(x, na.rm = TRUE))

# coverage
summary((N < resNormU) & (resNormL < N))
sapply(as.data.frame((N < resNormU) & (resNormL < N)), function (x) mean(x, na.rm = TRUE))
summary((N < resLogNormU) & (resLogNormL < N))
sapply(as.data.frame((N < resLogNormU) & (resLogNormL < N)), function (x) mean(x, na.rm = TRUE))
# average sie
summary(resNormU - resNormL)
summary(resLogNormU - resLogNormL)

write.csv(resPoint, file = "results/Hurdleztnegbin_linkage_error_point_est")
write.csv(resNormL, file = "results/Hurdleztnegbin_linkage_error_normalL")
write.csv(resNormU, file = "results/Hurdleztnegbin_linkage_error_normalU")
write.csv(resLogNormL, file = "results/Hurdleztnegbin_linkage_error_log_normalL")
write.csv(resLogNormU, file = "results/Hurdleztnegbin_linkage_error_log_normalU")

